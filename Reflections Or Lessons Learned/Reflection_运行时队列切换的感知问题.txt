问题：
        我需要在项目运行中能够替换掉队列，如何才能保证在切换掉队列后生产线程和消费线程能够立即感知到，立马重置切换到新队列呢？

思考：
      问题深度解析：
            倘若只是利用lockGlobally会出现什么问题呢？生产线程和消费线程可能都已经进入了旧队列offer和poll、remove的逻辑，那么即使
        使用全局锁，无法让线程感知到队列的切换，那么线程就会在旧队列中继续任务执行，倘若是生产线程倒还好，只是发生了数据存放到旧队列的丢失
        问题，如果是消费线程的非核心线程也还好，等到把旧队列消费完就会自己超时销毁，但如果是核心线程的话，那么就会一直消费旧队列直到为空然后
        阻塞，线程等于丢失，核心队列根本不会销毁，造成了空的旧队列还一直不被垃圾回收，并且核心线程一直循环，直至jvm停止，也就是说会有一些
        线程不干正事一直空转，并且旧队列无法被回收，又一个内存泄露问题！！！
      解决方案：
            其实问题就在于队列切换了之后那些在队列切换之前就开始消费或者生产在旧队列的线程没有感知到队列的切换，那么如何才能让线程感知到
        当前队列是旧队列呢？只需要在获取全局锁换好队列后将旧队列打上标记就行了，这样在出入队的时候检查一下当前队列的标记就行了。
            问题的细节：
                1 是否能在打上标记后立马被感知到呢？
                2 如果不能立马感知到那么这种延迟会不会有危害呢？
            解答：
                1 生产线程需要将检查逻辑放到锁后，这样切换队列和检查逻辑就是绝对先后串行关系，于是能立马感知到。消费线程同理。
                2 生产线程如果不能立马感知到，那么就会出现旧队列可能断断续续会有入队，并且无法确定什么时候所有生产线程全切换到新队列，
                很难有完美的补救方案，就会造成数据丢失。但是好就好在我所有的队列入队都是加锁的；出队线程如果无法及时感知到，那么依旧会
                出现空转问题，但是倘若出队有锁，那么就会立马感知到队列切换。如果队列无锁，那么也就只是过一小会就能够感知到了，因为无锁
                是cas操作，循环检查，那么过一会就能感知到了。
            解决方案就是：
                1 在队列设置成员变量，用来记录是否被切换，并且暴露给外部接口用来设置被切换。
                2 每次队列中的循环或者锁后面就添加检查逻辑，一旦发现被切换就抛出被切换异常。
            以上两种已经基本上解决所有问题，但是还有两种情况无法解决：
                1 使用ThreadBinding这种调度规则的，也就是使用了ThreadLocal，那么就会出现：当线程意识到队列的切换后就需要清除当前的
                ThreadLocal，那么就需要别的印记等方式去记录ThreadLocal清除是否完全，那么就相当于专门为了一个策略去做了一个几乎难以
                扩展的方式，所以不合理。
                2 从上面的推导可知消费线程使用无锁出队没有及时意识到队列的切换问题不太大，但是生产线程如果使用无锁入队从而没有意识到队列的
                切换那么就会有许多的元素可能会丢失在旧队列。

所以，最终的解决方案为：
        1 上述的两种解决方案组合
        2 再加上一个额外的小线程池用来执行兜底任务，可以比较好的解决上述两种问题，并还可以利用线程池做其他的异步任务。
            解决方式如下：
                ThreadLocal问题：只需要写个任务销毁当前的所有线程就行
                入队无锁问题：只需要写个任务销毁当前线程，等到这些线程全都被销毁（可以利用map来记录，非常容易），然后将旧队列消费完就行
            好处如下：
                异步迁移队列元素，异步销毁线程等等
